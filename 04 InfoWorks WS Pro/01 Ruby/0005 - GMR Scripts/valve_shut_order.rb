require 'date'
require 'time'

# Shows a UI prompt allowing the user to set the test options
# @param valve_count [Numeric] how many valves to test
# @return [DateTime] start time
# @return [DateTime] end time
# @return [Numeric] minutes between each valve closure
# @return [String] path to save the tests (with .CSV extension)
def get_user_options(valve_count)
  now = DateTime.now

  default_file = File.join(Dir.home, 'Documents', 'GMRTest.csv')

  opts = [
    ['Number of Valves Selected', 'READONLY', valve_count],
    ['Start Time', 'DATE', DateTime.new(now.year, now.month, now.day, 8, 0)],
    ['End Time', 'DATE', DateTime.new(now.year, now.month, now.day, 12, 0)],
    ['Time between valves (minutes)', 'NUMBER', 2],
    ['GMR CSV File', 'STRING', default_file.gsub!('/', '\\'), nil, 'FILE', false, 'CSV', 'GMR Comma Seperated Values', false]
  ]

  prompt = WSApplication.prompt("Valve GMR Shut Options", opts, true)

  return prompt[1], prompt[2], prompt[3], prompt[4]
end

# Confirms the user selection of valves and warns them if they're about to do something daft
# Does not return anything, will simply quit the script as necessary
#
# @param valves [Array<WSLink>] array containing the valve row objects
def are_you_being_daft(valves)
  if valves.empty? || valves.nil?
    WSApplication.message_box("No Valves selected!", 'OK', '!', true)
    exit
  end

  if valves.size == 1
    WSApplication.message_box("Only one valve selected - this would be very boring.", 'OK', '!', true)
    exit
  end

  permutations = (1..valves.size).inject(:*) || 1
  message = "You have #{valves.size} valves selected, which would result in #{permutations} test cases."
  message << "\n\nTrying to generate this many test cases will probably crash the program (or take a very long time).\n\nWant to try it anyway?" if valves.size >= 7
  response = WSApplication.message_box(message, 'YesNo', '?', true)
  exit if response != 'Yes'
end

# Save the test cases to CSV, using a bit of hacky string interpolation
#
# @param test_cases [Array<Hash>] array of hashes generated by the #make_test_cases method
# @return [String] the contents of the CSV to save
def test_cases_to_csv(test_cases)
  string = "**** gmr_test_case_instructions\n"
  string << "test_case_name,table_name,object_id,field_name,value\n"
  string << "**** wn_ctl_pipe_status\n"
  string << "test_case_name,table_name,object_id,field_name,ps_date_time,ps_closed\n"

  test_cases.each do |tc|
    string << "#{tc[:case_id]},wn_ctl_valve,#{tc[:id]},status,#{tc[:time].strftime("%F %T")},#{tc[:status]}\n"
  end

  return string
end

# Given the array of valves and some parameters, generates test cases for every possible order of valve closure.
# The valve closure is done via the pipe status bool for simplicity, since we're not trying to model valve closure
# over time (e.g. closing the valve over (x) minutes, and this accounts for all valve types e.g. 'shutting' a
# PRV without having to mess around with it's control mode.
#
# Valves are always open and shut in reverse order, i.e. last to be closed is the first to be opened.
#
# @param valves [Array<WSLink>] array containing the valve row objects
# @param [DateTime] start time
# @param [DateTime] end time
# @param [Numeric] time between valve closures
def make_test_cases(valves, start_time, end_time, time)
  cases = Array.new

  permutations = valves.permutation
  permutations.each_with_index do |array, i|
    case_name = "ValveShut_%03i" % [i]

    # Set initial status for each valve
    initial_time = Time.new(start_time.year, start_time.month, start_time.day)
    array.each { |valve| cases << {case_id: case_name, id: valve.id, time: initial_time, status: 0} }

    # Shut the valves
    array.each_with_index do |valve, step|
      step_time = start_time + Rational(step * time / 1440)
      cases << {case_id: case_name, id: valve.id, time: step_time, status: 1}
    end

    # Open them in reverse order
    array.reverse.each_with_index do |valve, step|
      step_time = end_time + Rational(step * time / 1440)
      cases << {case_id: case_name, id: valve.id, time: step_time, status: 0}
    end
  end

  return cases
end

network = WSApplication.current_network

# Get the currently selected valves as an array, and check this looks sensible
valves = network.row_objects_selection('wn_valve')
are_you_being_daft(valves)

# Generate the test cases
start_time, end_time, time, csv_path = get_user_options(valves.size)
test_cases = make_test_cases(valves, start_time, end_time, time)

# Generate and save the CSV
csv = test_cases_to_csv(test_cases)
File.write(csv_path, csv)
